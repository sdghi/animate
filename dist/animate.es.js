var t=Object.defineProperty,e=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable,i=(e,n,r)=>n in e?t(e,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[n]=r,s=(t,s)=>{for(var o in s||(s={}))n.call(s,o)&&i(t,o,s[o]);if(e)for(var o of e(s))r.call(s,o)&&i(t,o,s[o]);return t};function o(t,e=document){return"string"==typeof t?e.querySelector(t):t}function c(t,e=document){return"string"==typeof t?e.querySelectorAll(t):t}function l(t,e,n,r={duration:300,easing:"ease-in-out",direction:"forwards",scale:!0}){const i=t.top-e.top,s=t.left-e.left;let o=t.height/e.height,c=t.width/e.width;console.log(t.height,e.height,o,c);const l=n.animate([{transformOrigin:"top left",transform:`translate3d(${s}px, ${i}px, 0)  scale(${c}, ${o})`},{transformOrigin:"top left",transform:"none"}],{duration:r.duration,easing:r.easing,fill:"both"});"reverse"===r.direction?l.reverse():l.play(),r.done&&(l.onfinish=r.done)}function u(t){const e=t[0],n=t[1];return{inc:function(t,r){return t===n?e:t+r},dec:function(t,r){return t===e?n:t-r}}}const h={root:null,rootMargin:"0px",threshold:1};class a{constructor(t){this.el=o(t)}log(){console.log("element:",this.el)}node(){return this.el}scroll(t,e,n=h){let r=new IntersectionObserver((n=>{n.forEach((n=>{const r=n.intersectionRatio;"enter"===t&&n.isIntersecting&&this.scrollEnter(e),"exit"===t&&0===r&&this.scrollExit(e)}))}),n);const i=()=>{r.observe(this.el),requestAnimationFrame(i)};requestAnimationFrame(i)}scrollExit(t){t(this.el)}scrollEnter(t){t(this.el)}click(t){this.el.addEventListener("click",(e=>{t(this.el,e)}))}}function d(t,e){window.matchMedia(t).addEventListener("change",(t=>t.matches&&e.true?e.true():e.false?e.false():void 0))}function g(t,e,n){const r=o(t),i=r.getBoundingClientRect();e(r);l(i,r.getBoundingClientRect(),r,n)}function m(t,e,n,r){const i=o(t),s=i.getBoundingClientRect();i.style.visibility="hidden";const c=o(e),u=c.getBoundingClientRect();n(c),l(s,u,c,r)}function f(t,e,n,r){const i=o(t),s=i.querySelectorAll(e);let c=[];Array.from(s).map((t=>{const e=t.getBoundingClientRect();c.push(e)})),n(i),s.forEach(((t,e)=>{const n=t.getBoundingClientRect();l(c[e],n,t,r)}))}const p={lerp:()=>console.log("lerp")},x={itemSelector:".gallery__item",start:0};class I{constructor(t,e=x){this.options=e,this.el=o(t),this.items=c(e.itemSelector,this.el),this.currentIndex=e.start}node(){return this.el}getItems(){return this.items}getIndex(){return this.currentIndex}getCurrent(){return s({index:this.currentIndex},this.items[this.currentIndex])}getNext(){const t=u([0,this.items.length-1]).inc(this.currentIndex,1);return s({index:t},this.items[t])}getPrevious(){const t=u([0,this.items.length-1]).dec(this.currentIndex,1);return s({index:t},this.items[t])}getItem(t){return s({index:t},this.items[t])}next(t){this.currentIndex=u([0,this.items.length-1]).inc(this.currentIndex,1),t&&t(this.currentIndex)}previous(t){this.currentIndex=u([0,this.items.length-1]).dec(this.currentIndex,1),t&&t(this.currentIndex)}log(){console.log({el:this.el,options:this.options,items:this.items})}}export{I as Gallery,a as Watcher,f as animateLayout,m as crossfade,g as flip,c as getAllElements,o as getElement,u as loop,p as math,l as runFLIP,d as screen};
